Django:
比较重量,内部包含了非常多的组件
ORM, Form, ModelForm, Cache, Session,middleware, single, etc..

Flask: 
短小精悍,自己内部没有太多的组件,第三方的组件非常丰富
如果想把flask构造成和django一样的东西,是完全可以的,
开发简单 或 复杂的程序flask都可以, 因为可以使用flask的组件自己进行拼接
可定制性非常强, 对于开发不是太熟悉,又想让程序中更加便捷, 更多的组件来支持的时候可以用djano
当你开发大型系统的时候,这俩其实是都可以的,开发小的东西的时候,flask就比较简单

Tornado:
异步非阻塞框架

bottle:
bottle比flask更加的轻量

web.py:



1, 安装flask
a,
pip3 install flask

b,
wsgi, 帮助创建socket
在flask中使用werzeug实现的wsgi

werkzeug:

    from werzeug.wrappers import Request, Response
    	
    @Request.application
    def hello(request):
    	return Response('Hello World!')
    
    if __name__ = '__main__':
    	from werzeug.serving import run_simple
    	run_simple('localhost', 4000, hello)

wsgiref:
	
	from wsgiref.simple_server import make_server

	def runserver(environ, start_response):
		start_response('200 ok', [('[Content-Type,'text/html')])
		return [bytes('<h1>Hello, web!</h1>',encoding='uft-8'),]

	if __name__ == '__main__':
			httpd=make_server('',8000,runserver)
			httpd.serve_forever()

---

    @app.route('/login',methods=['GET'])
    def index():
    	if request.method == "GET":
    		return render_template('login.html')
    	else:
    		user = request.form.get('user')
    		pwd = reqeust.form.get('pwd')
    		if user == 'admin' and pwd == "password":
    			return redirect('http://www.xx.com')
    		return render_template('login.html', error="用户名或密码错误")
    			 

flask配置文件

方式1, 
app.config['DEBUG'] = True

方式2,
app.config.from_pyfile("python文件名称")

方式3,



1, 先执行app.route('/', methods=['GET','POST'],endpoint='n1') 返回值是 decorator函数

	def route(self, rule, **options):

		def decorator(f):
			endpoint = options.pop('endpoint',None)
			#endpoint是从options里面pop出来一个endpoint,如果没有传endpoint,默认是空的
			self.add_url_rule(rule, endpoint, f, **options)
			#self = app
			return f

		return decorator

2, @decorator

	decorator(index)

添加路由的本质就是执行 add_url_rule 这个方法

	
	def login():
		return '登陆'
	
	app.add_url_rule('/login','n2',login, methods=['GET','POST'])
	#如果endpoint可以是空的, 这里'n2'也可以是空的, 

	---
	
	@setupmethod
	def add_url_rule(self,rule,endpoint=None,view_func=None,**options):
		#view_func 相当于 login
		if endpoint is None:
			#如果endpoint是None, 会帮忙生成一个endpoint
			endpoint = _endpoint_from_view_func(view_func)
		options['endpoint'] = endpoint
		methods = options.pop('methods',None)

	---

	def _endpoint_from_view_func(view_func):
		assert view_func is not None, 'expected view func if endpoint '\
												'is not provided.'
		return view_func.__name__
		#取的就是函数名

对于flask, 它里面的路由可以通过flask来做, 但是进入装饰器里面的源码发现我们自己通过app.add_url_rule也可以来实现

settings.py 文件默认路径要放在程序root_path目录, 如果instance_relative_config为True, 则就是instance_path目录


	class IndexView(views.MethodView):
		methods = ['GET']
		decorators = [auth, ]
		
		def get(self):
			return 'Index.GET'

		def post(self):
			return 'Index.POST'

	app.add_url_rule('/index',view_func=IndexView.as_view(name='index'))
	#name='index', 这里的name指的就是刚才endp oint
	#虽然这里写的是一个类, 但是最终应该给返回一个函数的
	#/index 对应的就是一个内部的函数, 执行的是view函数
	
	---
	
	views.py
	
	@classmethod
	def as_view(cls, name, *class_args, **class_kwargs):
	
		def view(*args, **kwargs):
			self = view.view_class(*class_args, **class_kwargs)
			#view_class 指的就是当前的类
			return self.dispatch_request(*args, **kwargs)
		
		if cls.decorators:
			#cls是当前的类, 在类里面获取decorator
			view.__name__ = name
			view.__module__ = cls.__module__
			for decorator in cls.decorators:
				view = decorator(view)
				#这里循环相当于把咱们的函数在decorator里面套了一层又套了一层又套了一层
	
		view.view_class = cls
		#cls指的是当前执行as_view的类, 指的就是 class IndexView这个类
		#传一个name  是为了让endpoint = name
		view.__name__ = name
		view.__doc__ = cls.__doc__
		view.__module__ = cls.__module__
		view.methods = cls.methods
		#去类里面取methods
		return view

		def dispathc_reqeust(self, *args, **kwargs): 
		#这里是个反射
			meth = getattr(self, request.method.lower(),None)
			if meth is None and request.method == 'HEAD':
				meth = getattr(self, 'get', None)
			assert meth is not None, 'Unimplemented method %r' %request.method
			return meth(*args, **kwargs)
